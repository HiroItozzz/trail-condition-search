# Trail Condition Portal - 設計意図と運用方針

## 全体の設計哲学

### 根本思想
**「生データは保存、正規化は段階的」**
- スクレイピングした原文は必ず保存（トレーサビリティ）
- AI正規化は別カラムで管理（元データを壊さない）
- 手作業は最小限に、段階的に自動化

---

## 各モデルの存在理由

### DataSource (情報源)

**目的:**
- スクレイピング対象サイトの一元管理
- URLや設定を管理画面から変更可能に

**なぜ必要か:**
- サイトURLが変わった時、コード修正せずに対応
- 新しい情報源を追加する時、管理画面から操作
- どの情報源から取得したか追跡可能

**管理者の手作業:**
- 新しいスクレイピング対象の追加
- URL変更時の更新
- 情報源の有効/無効切り替え

**自動化:**
- スクレイピング処理は自動実行
- URL から自動でデータ取得

---

### AreaName (エリア定義)

**目的:**
- 地理的な分類の統一
- AI正規化の精度向上

**なぜ TextChoices で定義:**
- コード内で型安全に扱える
- 管理画面でドロップダウン表示
- Pydantic/AI でも使用可能

**なぜ TrailCondition.area が必要:**
- スクレイピング時に情報源から取得した「生のエリア情報」
- AI に渡すことで正規化精度が向上
- MountainGroup.area とは役割が違う（生データ vs 正規化後）

**管理者の手作業:**
- なし（コードで定義）

**自動化:**
- スクレイピング時に情報源から自動取得
- AI が自動判定

---

### StatusType (状況種別)

**目的:**
- 危険情報の分類統一
- UI での色分け・アイコン表示

**なぜクラス外で定義:**
- Pydantic でも同じ定義を使うため（DRY原則）
- AI に JSON Schema として渡す

**なぜ絵文字付き:**
- UI で視覚的に分かりやすい
- AI にも意味を伝えやすい（補助的）

**管理者の手作業:**
- なし（コードで定義）
- 分類が増えた時のみコード追加

**自動化:**
- AI が自動判定

---

### TrailCondition (登山道状況) ※コアモデル

**目的:**
- 危険情報の保存と提供

**フィールド設計の意図:**

#### source, url
- **目的:** 情報の出典を明確に
- **なぜ:** トレーサビリティ、信頼性
- **自動化:** スクレイピング時に自動設定

#### mountain_name_raw, trail_name, title, description
- **目的:** 原文をそのまま保存
- **なぜ:** AI正規化が失敗しても元データは残る
- **自動化:** スクレイピング時に自動取得

#### area
- **目的:** スクレイピング時の半正規化データ
- **なぜ:** AI正規化の精度向上、フィルタリング
- **重要:** MountainGroup.area とは別概念（生データ vs 正規化）
- **自動化:** スクレイピング時に情報源から自動取得

#### status
- **目的:** AI が判定した危険レベル
- **なぜ:** ユーザーが一目で危険度を判断できる
- **自動化:** AI が自動判定

#### reported_at
- **目的:** いつ報告された情報か
- **なぜ:** 古い情報を判別、最新情報のみ表示
- **自動化:** スクレイピング時に記事の日付を自動取得

#### resolved_at, resolved_description
- **目的:** 通行止め等の問題が解消された日時と説明
- **なぜ:** 1レコード内で発生から解消までの履歴を保持
- **判定:** `resolved_at` が None なら未解消、値があれば解消済み
- **メリット:** 
  - データ量削減（新レコード不要）
  - 発生〜解消の期間が明確
  - 同じレコードで完結
- **手作業:** 管理画面で解消日時を入力
- **自動化:** AI が解消記事を検出（将来）

#### disabled
- **目的:** 誤情報・重複情報の無効化（管理用）
- **なぜ:** 削除せずに無効化（履歴として残す）
- **用途:**
  - スクレイピングミスを発見した時
  - 重複したレコード
  - 明らかな誤情報
- **重要:** 通行止め解除には使わない（resolved_at を使う）
- **手作業:** 管理画面でチェックボックス切り替え
- **自動化:** なし（人間の判断が必要）

#### mountain_group (将来実装)
- **目的:** 地図UI での山のグルーピング
- **なぜ今は不要:** 地図UI実装前は使わない
- **いつ実装:** フロントエンドで地図表示する時
- **自動化:** AI提案 + 手動確認（将来）

---

### MountainGroup (将来実装)

**目的:**
- 地図UI で山をグルーピング表示
- 例: 「大岳山エリア」に複数の山をまとめる

**なぜ今は実装しない:**
- 地図UI がまだない
- area だけで当面は運用可能
- 後から追加してもデータ移行可能

**いつ実装するか:**
- フロントエンドで地図表示機能を作る時
- ユーザーが「エリアで絞り込み」を必要とした時

**特徴:**
- 恣意的な分類（ビジネスロジック）
- 地理的距離ではなく「有名な山を中心としたエリア」
- 例: 大岳山、御岳山、川苔山 → 「大岳山グループ」

**手作業:**
- グループの定義（どの山をどうまとめるか）
- 後述の MountainAlias との紐付け

---

### MountainAlias (将来実装)

**目的:**
- 山名の表記ゆれを吸収
- 例: "馬頭刈山" → "大岳山グループ"

**なぜ今は実装しない:**
- MountainGroup がまだない
- mountain_name_raw で十分運用可能

**Signal連携の意図:**
```python
# MountainAlias を追加した時
# 過去の TrailCondition も自動更新
@receiver(post_save, sender=MountainAlias)
def update_existing_conditions(sender, instance, created, **kwargs):
    if created:
        TrailCondition.objects.filter(
            mountain_name_raw=instance.alias_name,
            mountain_group__isnull=True
        ).update(mountain_group=instance.mountain_group)
```

**なぜこの仕組み:**
- 1回 Alias 追加 → 過去データも自動紐付け
- 手作業を最小化

**手作業:**
- Alias の追加（管理画面から）
- 例: 「馬頭刈山は大岳山グループ」を登録

**自動化:**
- 追加後の既存データ更新は自動
- AI による候補提案（将来）

---

## 通行止め解除の表現方法

**設計意図:**
- 通行止め解除 = 同じレコードの `resolved_at` に日時を設定

**方法:**
```python
# 通行止め発生
condition = TrailCondition.objects.create(
    mountain_name_raw="雲取山",
    trail_name="鴨沢ルート",
    status=StatusType.CLOSURE,
    reported_at="2025-01-01",
    resolved_at=None  # 未解消
)

# 解消（同じレコードを更新）
condition.resolved_at = "2025-01-10"
condition.resolved_description = "落石撤去により通行可能"
condition.save()

# 判定
if condition.resolved_at:
    print("解消済み")
else:
    print("未解消")
```

**メリット:**
- 1レコードで発生〜解消の履歴が見れる
- データ量削減
- 発生から解消までの期間が計算できる

**正しい方法:**
```
✅ 正しい使い方:
# 通行止め発生
TrailCondition.objects.create(
    mountain_name_raw="雲取山",
    trail_name="鴨沢ルート",
    status=StatusType.CLOSURE,
    reported_at="2025-01-01"
)

# 解除（新レコード）
TrailCondition.objects.create(
    mountain_name_raw="雲取山",
    trail_name="鴨沢ルート",
    status=StatusType.SAFE,
    reported_at="2025-01-10"
)

# 最新状態を取得
latest = TrailCondition.objects.filter(
    mountain_name_raw="雲取山",
    trail_name="鴨沢ルート",
    is_active=True
).order_by('-reported_at').first()
```

**メリット:**
- 履歴が残る
- いつ解除されたか分かる
- データの意味が明確

---

## 管理画面での手作業

### 必須の手作業

**1. DataSource の管理**
- 新しいスクレイピング対象を追加
- URL が変更された時の更新

**頻度:** 低（月1回以下）

---

**2. resolved_at の設定**
- 通行止め等が解消されたことを確認
- 解消日時と説明を入力

**頻度:** 中（週数回）

---

**3. disabled の管理**
- 誤情報を発見した時に無効化
- 重複情報の無効化

**頻度:** 低（週1回程度）

---

### 将来的な手作業（MountainGroup実装後）

**3. MountainGroup の定義**
- どの山をどうグルーピングするか
- 例: 「大岳山グループには馬頭刈山も含める」

**頻度:** 最初だけ（初期設定）

---

**4. MountainAlias の追加**
- 新しい山名が出てきた時
- 例: 「榧ノ木山は大岳山グループ」

**頻度:** 低（月数回）
**軽減策:** AI が候補提案（将来）

---

### 自動化されている部分

**スクレイピング:**
- 1日1回自動実行
- URL取得、データ抽出

**AI正規化:**
- status の自動判定
- description の要約

**データ更新:**
- MountainAlias 追加時の過去データ更新（Signal）

---

## データの流れと責任分担
```
スクレイピング（自動）
    ↓
生データ保存（自動）
  - resolved_at = None（未解消）
  - disabled = False（有効）
    ↓
AI正規化（自動）
  - status 判定
    ↓
DB保存（自動）
    ↓
━━━━━━━━━━━━━━━━━━━━
管理画面（手作業）
    ↓
解消情報の入力（たまに）
  - resolved_at に日時を設定
  - resolved_description を入力
    ↓
誤情報チェック（たまに）
  - disabled = True
```

---

## なぜこの設計か

### 原則1: 生データは絶対に保存
**理由:**
- AI が間違える可能性
- 後で見直せる
- トレーサビリティ

---

### 原則2: 正規化は段階的
**理由:**
- 最初から完璧を目指さない
- area だけでも十分価値がある
- MountainGroup は後で追加可能

---

### 原則3: 手作業は最小限
**理由:**
- 運用コストを下げる
- 持続可能性
- 段階的に自動化

---

### 原則4: 履歴は削除しない
**理由:**
- is_active で無効化
- 通行止め解除は新レコード
- データの完全性

---

## 将来の拡張計画

### Phase 1: 基本機能（現在）
- スクレイピング
- AI正規化（status判定）
- area での分類
- **手作業:** is_active管理のみ

---

### Phase 2: 地図UI
- MountainGroup 実装
- MountainAlias 実装
- 地図での表示
- **手作業:** グループ定義、Alias追加

---

### Phase 3: 高度な自動化
- AI が MountainGroup を提案（確信度付き）
- 確信度が高ければ自動設定
- 低ければ手動確認
- **手作業:** AI提案の確認のみ

---

## まとめ：忘れないためのチェックリスト

### MountainGroup
- [ ] 目的: 地図UI のため
- [ ] 今は不要
- [ ] area だけで当面OK
- [ ] 後から追加可能

### area vs mountain_group.area
- [ ] TrailCondition.area: 情報源の生データ
- [ ] MountainGroup.area: 正規化後のエリア
- [ ] 役割が違うので重複ではない

### is_active
- [ ] 用途: 誤情報・古い情報の無効化
- [ ]
### disabled
- [ ] 用途: 誤情報・古い情報の無効化
- [ ] 通行止め解除には使わない
- [ ] 解除 = 新レコード作成

### 手作業
- [ ] DataSource 管理: たまに
- [ ] is_active 切り替え: たまに
- [ ] MountainGroup: 将来、初期のみ
- [ ] MountainAlias: 将来、たまに

### 自動化
- [ ] スクレイピング: 完全自動
- [ ] AI正規化: 完全自動
- [ ] area取得: 自動
- [ ] status判定: 自動