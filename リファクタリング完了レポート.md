# 登山道状況ポータル - LLMモジュール リファクタリング完了レポート

## 概要
Django登山道状況ポータルプロジェクトのLLM関連コードの大規模リファクタリングを実施。コードの保守性、テスト性、再利用性を大幅に向上させました。

## 主要な変更内容

### 1. ファイル構造の整理

#### ディレクトリ構造の変更
```
trail_status/services/
├── ai_config/ → prompts/ (リネーム)
├── config/ (新規作成)
│   └── ai_models.yaml
├── llm_client.py (大幅リファクタリング)
├── pipeline.py (新規作成)
└── synchronizer.py (修正)
```

#### 新規作成されたファイル
- `trail_status/services/config/ai_models.yaml` - AI設定ファイル
- `trail_status/services/pipeline.py` - メインパイプライン処理
- `trail_status/management/commands/scrape_trail_conditions.py` - 統合コマンド

### 2. LLMクライアントの近代化

#### APIキー管理の自動化
```python
# Before: 手動でAPIキー渡し
config = LlmConfig(model="deepseek-reasoner", prompt=prompt, data=data, api_key=api_key)

# After: 自動取得
@computed_field
@property
def api_key(self) -> str:
    if self.model.startswith("deepseek"):
        key = os.environ.get("DEEPSEEK_API_KEY")
        if not key:
            raise ValueError("環境変数 DEEPSEEK_API_KEY が設定されていません")
        return key
    # ...
```

#### クラスメソッドの追加
```python
# 新機能: サイト設定からの自動生成
config = LlmConfig.from_site("okutama", data=scraped_data, model="deepseek-reasoner")
```

#### thinking_budget パラメータ追加
```python
class LlmConfig(BaseModel):
    thinking_budget: int = Field(default=5000, ge=-1, le=15000, description="Geminiの思考予算（トークン数）")
```

### 3. テストモジュールの現代化

#### unittest → pytest移行
```python
# Before: Django TestCase
class LlmClientTest(TestCase):
    def setUp(self):
        # ...

# After: pytest with fixtures
@pytest.fixture
def mock_api_keys(monkeypatch):
    monkeypatch.setenv("DEEPSEEK_API_KEY", "test-key")
```

#### テストファイル分割
- `test_llm_config.py` - 設定バリデーション
- `test_llm_clients.py` - クライアント機能
- `test_config_files.py` - ファイル読み込み
- `test_schema_validation.py` - スキーマ検証

#### conftest.py作成
共有フィクスチャとpytest設定を統合

### 4. パス管理の改善

#### Django設定ベースのパス解決
```python
# Before: ハードコード
Path("/code/trail_status/services/prompts/mitake.yaml")

# After: Django設定使用
def get_prompts_dir():
    return settings.BASE_DIR / "trail_status" / "services" / "prompts"
```

### 5. データ同期処理の修正

#### synchronizer.pyの問題修正
```python
# Before: 存在しないフィールドを除外
generated_data = data.model_dump(exclude={"source", "mountain_name_raw", "trail_name"})

# After: 正しいフィールド除外
generated_data = data.model_dump(exclude={"mountain_name_raw", "trail_name"})
```

#### 原文保存の徹底
AIを信頼し、正規化せずに原文そのままをデータベースに保存

### 6. management commandsの更新

#### 既存コマンドの近代化
```python
# Before: 手動プロンプト読み込み
prompt = yaml.safe_load(prompt_path.read_text())["prompt"]
d_config = LlmConfig(model="deepseek-reasoner", prompt=prompt, data=data)

# After: 自動化されたメソッド使用
d_config = LlmConfig.from_site(config_name, data=data, model="deepseek-reasoner")
```

### 7. 統合パイプライン作成

#### アーキテクチャパターンの適用
```python
# services/pipeline.py - ビジネスロジック
class TrailConditionPipeline:
    async def process_all_sources(self, sources, model, dry_run=False):
        # パイプライン処理

# management/commands/ - 薄いレイヤー
class Command(BaseCommand):
    def handle(self, *args, **options):
        pipeline = TrailConditionPipeline()
        results = asyncio.run(pipeline.process_all_sources(...))
```

#### 完全なデータフロー
```
DataSource → fetcher.py → llm_client.py → synchronizer.py → TrailCondition
```

## 技術的メリット

### 1. 保守性の向上
- **設定の一元化**: YAML設定ファイルによる管理
- **コードの分離**: 責任ごとにモジュール分割
- **エラーハンドリング**: 適切な例外処理とログ出力

### 2. テスト性の向上
- **pytest導入**: モダンなテストフレームワーク
- **フィクスチャ活用**: 再利用可能なテスト設定
- **モック対応**: API呼び出しの適切なモック化

### 3. 再利用性の向上
- **pipeline.py**: APIやCeleryタスクからも利用可能
- **from_site()メソッド**: 簡潔な設定生成
- **computed_field**: 自動APIキー解決

### 4. 運用性の向上
- **DRY-RUN機能**: 安全なテスト実行
- **並行処理**: 複数ソースの効率的処理
- **詳細ログ**: トラブルシューティング支援

## 使用方法

### 基本的な実行
```bash
# 全ての情報源を処理
python manage.py scrape_trail_conditions

# 特定の情報源のみ
python manage.py scrape_trail_conditions --source 1

# Geminiを使用
python manage.py scrape_trail_conditions --model gemini-3-flash-preview

# DRY-RUN（DB保存なし）
python manage.py scrape_trail_conditions --dry-run
```

### テスト実行
```bash
# pytest実行
docker compose exec web uv run pytest trail_status/tests/

# 既存のLLMテスト
docker compose exec web uv run manage.py test_llm
```

### プログラム内での使用
```python
from trail_status.services.pipeline import TrailConditionPipeline

pipeline = TrailConditionPipeline()
results = await pipeline.process_all_sources(sources, model="deepseek-reasoner")
```

## 今後の拡張可能性

### 1. 新しいAIモデルの追加
- LlmConfig の pattern フィールドを更新
- 対応するクライアントクラスを作成

### 2. 新しいデータソースの追加
- site_name_mapping に追加
- 対応するYAML設定ファイルを作成

### 3. スケジューリング
```bash
# cron job例
0 */6 * * * cd /app && python manage.py scrape_trail_conditions
```

### 4. 監視とアラート
- 処理結果をSlack/Discordに通知
- エラー時の自動アラート

## まとめ

本リファクタリングにより、以下を実現：

1. **技術負債の解消** - ハードコード、混在したテスト・本番コード
2. **モダンなPython実践** - Pydantic computed fields、pytest、async/await
3. **Django ベストプラクティス** - management commands、設定管理
4. **拡張性の確保** - プラグイン的な設計、明確な責任分離

登山道状況ポータルのLLMモジュールが、保守性・テスト性・運用性に優れたモダンなPython/Djangoアプリケーションに生まれ変わりました。